# sequences/tuples/tuples.py

# Нумерация индексов начинается с 0 (нуля).
      
my_tuple = (1, 2, 3)
print(my_tuple[0])  # 1

print(my_tuple[10])  # IndexError


# При сравнение используется лексикографический порядок, сравниваются два элемента, идущих друг за другом, начиная с первого. 
# Последовательности равны, если их элементы равны.

print((1, 2, 3) < (1, 2, 4))  # True
print([1, 2, 3] < [1, 2, 4])  # True

# При лексикографическом сравнении для строк используются номера кодовых точек Юникода.    

print('ABC' < 'C' < 'Pascal' < 'Python')

# Вложенные последовательности одинакового типа сравниваются рекурсивно. 

print((1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4))
  


# Кортеж можно объявить при помощи конструктора tuple(), 
# в качестве аргумента которому можно передать последовательность или объект, поддерживающий итерирование (включая генераторы). 
tuple() # ()

tuple('abc')  # ('a', 'b', 'c')
tuple([1, 2, 3])  # (1, 2, 3)

# Если аргументом указан кортеж, то он и будет возвращен без изменений.

tuple((1, 2, 3)) # (1, 2, 3)

# Объявление tuple
t = 1,[2,3]
print(t)
p = (1.2, 3.4, 0.9)
one_item = (1, )

empty_tuple = ()
p1 = 1, 3, 9
p2 = 3, 8, 5, # тоже три элемента

# Пустой кортеж - это глобально уникальный объект. 

a = ()
b = ()

# Все пустые кортежи - это один и тот же объект, а значит и адрес в памяти у таких кортежей один.

a is b # True
id(a) == id(b)  # True

# Обмен значений переменных с помощью кортежей
a,b=1,2
print(a,b)

# код действительно проще и изящнее:
a, b = b, a
print(a,b)

# Можно осуществлять присваивание одного объекта нескольким переменным
a=b=c=1
# Это равносильно
c=1; b=c; a=b

# Такое присваивание удобно выполнять для неизменяемых объектов. 
# Следует учитывать, что если присваивается изменяемый объект, то при его изменении с помощью одной переменной, изменяются и другие переменные.

a=b=c=[]
a.append(1)
print(a,b,c)

# Функция tuple() берет в качестве аргумента строку или список и превращает его в кортеж:

tuple('abc')
print(tuple('abc'))

# Присваивание строки кортежу
a,b,c='ijk'
print(a,b,c)

# При удалении кортежа (например, с помощью del, или сборщика мусора) небольшой длины (не более 19 элементов), он не удаляется сразу, а перемещается в очередь удаления. Эта очередь имеет 20 групп, в каждую из которых помещаются удаленные кортежи соответствующей длины, причем в первой группе хранится пустой кортеж.

tuple_0 = (1, 2, 3)
print('tuple_0 %s' % id(tuple_0))  # 140332152236648

tuple_1 = (1, 2, 3)
print('tuple_1 %s' % id(tuple_1))  # 140332152236720

del tuple_1

# Далее предполагается, что сборка мусора уже прошла.

tuple_2 = (1, 2, 4)
print('tuple_2 %s' % id(tuple_2))  # 140332152236720


